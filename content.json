{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"SpringCloudAlibaba","date":"2021-11-16T09:22:56.430Z","updated":"2021-11-16T16:43:23.458Z","comments":true,"path":"2021/11/16/SpringCloudAlibaba/","link":"","permalink":"http://example.com/2021/11/16/SpringCloudAlibaba/","excerpt":"","text":"SpringCloudAlibaba为什么要用SpringCloudAlibaba1.SpringCloud说实话已经不再完整了，它的很多组件已经闭包了，换句话说就是不在提供维护了2.性能方面SpringCloud Alibaba 比SpringCloud 高很多3.稳定，阿里巴巴相信大家都很熟悉，基本不会跑路的4.不管是孵化失败，还是别的原因导致了它不在完整了，所以我们要学习albb的5.阿里巴巴高并发等方面是有目共睹的，性能肯定好，而且简单6.SpringCloud有基础的可以直接转SpringCloud Alibaba————————————————版权声明：本文为CSDN博主「常家壮」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_44257023/article/details/107513261 SpringCloudAlibaba简介Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。 依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。 此外，阿里云同时还提供了 Spring Cloud Alibaba 企业版 微服务解决方案，包括无侵入服务治理(全链路灰度，无损上下线，离群实例摘除等)，企业级 Nacos 注册配置中心和企业级云原生网关等众多产品。 参考文档 请查看 WIKI 。 为 Spring Cloud Alibaba 贡献代码请参考 如何贡献 。 主要功能 服务限流降级：默认支持 WebServlet、WebFlux、OpenFeign、RestTemplate、Spring Cloud Gateway、Zuul、Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。 服务注册与发现：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。 分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新。 消息驱动能力：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。 分布式事务：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。 阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。 分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。 阿里云短信服务：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。 更多功能请参考 Roadmap。 除了上述所具有的功能外，针对企业级用户的场景，Spring Cloud Alibaba 配套的企业版微服务治理方案 微服务引擎MSE 还提供了企业级微服务治理中心，包括全链路灰度、服务预热、无损上下线和离群实例摘除等更多更强大的治理能力，同时还提供了企业级 Nacos 注册配置中心，企业级云原生网关等多种产品及解决方案 组件**Sentinel**：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。 **Nacos**：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 **RocketMQ**：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。 **Dubbo**：Apache Dubbo™ 是一款高性能 Java RPC 框架。 **Seata**：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。 Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。 Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。 Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。 搭建引入依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;order&lt;/module&gt; &lt;module&gt;stock&lt;/module&gt; &lt;/modules&gt; &lt;!--springboot父类管理--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.ayan.springcloud&lt;/groupId&gt; &lt;artifactId&gt;springcloudalibaba&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springcloudalibaba&lt;/name&gt; &lt;description&gt;Spring Cloud Alibaba&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring.cloud.alibaba.version&gt;2.2.5.RELEASE&lt;/spring.cloud.alibaba.version&gt; &lt;spring.cloud.version&gt;Hoxton.SR8&lt;/spring.cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--SpringBoot基本场景启动依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--SpringBoot测试依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--管理依赖--&gt; &lt;dependencyManagement&gt; &lt;!--Spring Cloud alibaba的版本管理，通过dependency完成继承--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.cloud.alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--SpringCloud版本管理--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; Nacos什么是Nacos？spring远程服务调用 123456@Bean //RestTemplate实例交给spring进行管理 public RestTemplate restTemplate(RestTemplateBuilder builder)&#123; RestTemplate restTemplate = builder.build(); return restTemplate; &#125; 下订单同时调用远程的减库存接口 123456789101112131415@RestController@RequestMapping(&quot;/order&quot;)public class OrderController &#123; @Autowired RestTemplate restTemplate; @GetMapping(&quot;/add&quot;) public String add()&#123; System.out.println(&quot;下单！&quot;); String msg = restTemplate.getForObject(&quot;http://localhost:8011/stock/reduce&quot;, String.class); return &quot;下单成功！&quot;+msg; &#125;&#125; 这种远程调用方式管理起来太麻烦！！！ 于是就需要一个注册中心，来管理这些接口。 SpringCloudAlibaba就提供了一个注册中心组件。 Nacos官方描述：一个更易于构建云原生应用的动态服务注册发现(Nacos Discovery)、配置管理(Nacos Config)和服务管理平台。 其实就相当于:eureka、consul等传统注册中心方案)+配置中心(spring cloud config)来使用。 Nacos的关键特性包括： 服务注册发现(Nacos Discovery,核心)和服务健康检测(心跳机制，定时任务) 动态配置服务(心跳机制，定时任务) 动态DNS服务 服务及其元数据管理 Nacos注册中心CAP协议 ： C一致性A可用性P分区容错性 Nacos支持CP或AP协议的切换 核心功能服务注册：Nacos Client会通过发送REST请求的方式向Nacos Server注册自己的服务，提供自身的元数据，比如ip地址、端口等信息。Nacos Server接收到注册请求后，就会把这些元数据信息存储在一个双层的内存Map中。 服务心跳：在服务注册后，Nacos Client会维护一个定时心跳来持续通知Nacos Server，说明服务一直处于可用状态，防止被剔除，默认5s发送一次心跳。 服务同步：Nacos Server集群之间会互相同步服务实例，用来保证服务信息的一致性。leader raft。 服务发现：服务消费者（Nacos Client）在调用服务提供者的服务时。会发送一个REST请求给Nacos Server，获取上面注册的服务清单，并且缓存在Nacos Client本地，同时会在Nacos Client本地开启一个定时任务定时拉取服务端最新的注册表信息更新到本地缓存。 服务健康检查：Nacos Server会开启一个定时任务来检查注册服务实例的健康情况，对于超过15s没有收到客户端心跳的实例会将它的healthy属性设置为false（客户端服务发现时不会发现），如果某个实例超过30秒没有收到心跳，直接剔除该实例（被剔除的实例如果恢复发送心跳则会重新注册） 子项目依赖nacos 12345&lt;!--nacos服务注册发现依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; 在application.yml配置文件中进行nacos配置 1234567891011121314151617server: port: 8020spring: application: #应用名称（nacos会将该名称当作服务名称） name: order-service cloud: nacos: server-addr: 192.168.1.102 discovery: username: nacos password: nacos namespace: public #默认public，相同特征的服务进行归类分组管理 #ephemeral: false #默认为true就是临时实例，false为永久实例，哪怕宕机也不会从服务列表删除 #service: 默认取$&#123;spring.application.name&#125;,也可以通过该选项配置 #group： 默认DEFAULT_GROUP,更细化的相同特征的服务进行归类分组管理 #weight: 通常要结合按照权重的负载均衡策略，权重越高分配的流量就越大 更多配置：spring-cloud-alibaba/nacos-discovery.adoc at master · alibaba/spring-cloud-alibaba (github.com) nacos默认集成ribbon负载均衡，通过注解@LoadBalanced实现 1234567@Bean @LoadBalanced//默认ribbon负载均衡 //RestTemplate实例交给spring进行管理 public RestTemplate restTemplate(RestTemplateBuilder builder)&#123; RestTemplate restTemplate = builder.build(); return restTemplate; &#125; 然后 启动下载好的nacos：startup.cmd，可以记事本打开更改单机模式还是集群模式，默认是集群模式，application.properties还改可以更改数据持久化机制，可以选择mysql存储。默认端口8840，也可更改。 启动后，访问 http://localhost:8848/nacos/index.html即可打开nacos控制界面。 雪崩保护： ​ 保护阈值：可以设置0-1之间的值 ​ 临时实例： 12345spring: cloud: nacos: discovery: ephemeral: false #false为永久实例，哪怕宕机也不会从服务列表删除 健康实例，不健康实例； 如果健康实例数/总实例&lt;保护阈值，就会去调用不健康实例 权重：结合负载均衡策略使用 下线：下线就不会调用了 Nacos集群负载均衡Ribbon负载均衡方案分为两种： 集中式负载均衡，在消费者和服务提供者中间使用独立的代理方式进行负载，有硬件的(比如F5)，也有软件的(比如Nginx)。 客户端负载均衡，客户端根据自己的情况做负载均衡，Ribbon就属于客户端自己做负载均衡。 SpringCloud Ribbon是基于Netflix Ribbon实现的一套客户端的负载均衡工具，Ribbon客户端组件提供一系列的完善的配置，如超时，重试等。通过Load Balancer获取到服务提供的所有机器实例，Ribbon会自动基于某种规则(轮询，随机，最小连接数)去调用这些服务。Ribbon也可以实现我们自己定义的负载均衡算法。 常见的负载均衡算法： 随机，通过随机选择服务执行，一般这种方式使用较少； 轮询，负载均衡默认实现方式，请求来了之后服务排队处理； 加权轮询，通过对服务器性能的分型，给高配置，低负载的服务器分配更高的权重，均衡各个服务器的压力； 地址Hash，通过客户端请求的地址的Hash值取模映射进行服务器调度。ip==&gt;hash 最小连接数，即使请求均衡了，压力不一定会均衡，最小连接数就是根据服务器的情况，将请求分配到当前压力最小的服务器上。也叫最小活跃数。 Nacos使用Ribbonnacos-discovery已经依赖了ribbon，可以不用再引入了。 添加@LoadBalanced注解 123456789101112131415@SpringBootApplication//@EnableDiscoveryClient(可加可不加)public class OrderApp &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderApp.class,args); &#125; @Bean//RestTemplate实例交给spring进行管理 @LoadBalanced//默认ribbon负载均衡 public RestTemplate restTemplate(RestTemplateBuilder builder)&#123; RestTemplate restTemplate = builder.build(); return restTemplate; &#125;&#125; 然后调用时使用服务名spring.cloud.nacos.discovery.service= 默认取${spring.application.name},也可以通过该选项配置服务名。来通过负载均衡策略调用服务。 controller 123456789101112131415@RestController@RequestMapping(&quot;/order&quot;)public class OrderController &#123; @Autowired RestTemplate restTemplate; @GetMapping(&quot;/add&quot;) public String add()&#123; System.out.println(&quot;下单！&quot;); String msg = restTemplate.getForObject(&quot;http://stock-service/stock/reduce&quot;, String.class); return &quot;下单成功！&quot;+msg; &#125;&#125; OpenFeign导入依赖包 12345&lt;!--添加openfeign依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; springboot启动类添加OpenFeign注解@EnableFeignClients 123456789@SpringBootApplication@EnableFeignClients//@EnableDiscoveryClient(可加可不加)public class OrderApp &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderApp.class,args); &#125;&#125; 写一个本地的接口，实现需要调用的远程service接口 1234567891011121314151617181920212223242526272829/** * 添加feign接口和方法 * name 指定调用rest接口所对应的服务名 * path 指定调用rest接口所在的stockController指定的@RequestMapping */@FeignClient(name=&quot;stock-service&quot;,path = &quot;/stock&quot;)public interface StockFeignService &#123; //声明需要调用的rest接口对应的方法 @GetMapping(&quot;/reduce&quot;) String reduce();&#125;/*远程减库存服务*@RestController@RequestMapping(&quot;/stock&quot;)public class StockController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) String port; @GetMapping(&quot;/reduce&quot;) public String reduce()&#123; System.out.println(&quot;扣减库存！&quot;); return &quot;扣减库存成功！&quot;+port; &#125;&#125;** */ Controller调用远程减库存服务,依赖注入写好的本地调用远程服务的接口 123456789101112131415@RestController@RequestMapping(&quot;/order&quot;)public class OrderController &#123; @Autowired StockFeignService stockFeignService; @GetMapping(&quot;/add&quot;) public String add()&#123; System.out.println(&quot;下单！&quot;); String msg = stockFeignService.reduce(); return &quot;下单成功！Hello Feign&quot;+msg; &#125;&#125; OpenFeign还会默认去使用Ribbon负载均衡策略","categories":[],"tags":[]},{"title":"Swagger","slug":"Swagger","date":"2021-11-06T16:00:00.000Z","updated":"2021-11-15T15:11:18.819Z","comments":true,"path":"2021/11/07/Swagger/","link":"","permalink":"http://example.com/2021/11/07/Swagger/","excerpt":"","text":"Swagger学习目标： 了解Swagger的作用和盖帘 了解前后端分离 在SpringBoot中国集成Swagger Swagger前后端分离 Vue + SpringBoot 后端时代：前端只用管理静态页面；html&gt;后端。模板引擎Jsp&gt;后端是主力 前后端分离时代： 后端：后端控制层(Controller)，服务层(Service)，数据访问层(DAO)【后端团队】 前端：前端控制层，视图层【前端团队】 伪造后端数据，json。已经存在了，不需要后端接口，前端工程依旧能够跑起来 前后端如何交互？===&gt;API 前后端相互独立，松耦合； 前后端甚至可以部署在不同的服务器上； 产生一个问题： 前后端集成联调，前端人员和后端人员无法做到“及时协商，尽早解决”，最终导致问题集中爆发； 解决方案： 首先指定schema【计划的提纲】，实时更新最新API,降低集成的风险； 在Swagger之前：通过制定word计划API文档 前后端分离： 测试后端接口：postman 后端提供接口，需要实时更新最新的消息及需求改动！ 哪里有需求哪里就有市场，于是Swagger就应运而生了 Swagger 号称世界上最流行的Api框架 RestFul API 文档在线自动生成工具==&gt;Api文档与Api定义同步更新 直接运行，可以在线测试API接口 支持多种语言：（Java，Php） 官网：https://swagger.io/ SpringBoot集成Swagger 新建一个SpringBoot，web项目 导入相关依赖，在项目使用Swagger需要依赖jar包 Springbox(Swagger3) 123456&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; 编写一个Hello工程 Application上面加入@EnableOpenApi注解 配置Swagger==&gt; Config Swagger3的访问路径由port/swagger-ui.html改成了port/swagger-ui/ 或port/swagger-ui/index.html 12345678910111213141516171819202122232425@Configuration//声明配置类@EnableOpenApi//开启swagger3public class SwaggerConfig &#123; //配置Swagger的Docket的bean实例 @Bean public Docket docket()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()); &#125; //配置swagger信息=apiinfo private ApiInfo apiInfo() &#123; //作者信息 Contact contact = new Contact(&quot;AYAN&quot;,&quot;https://dayanhan.github.io/&quot;,&quot;1738340585@qq.com&quot;); return new ApiInfo( &quot;AYAN的SwaggerAPI文档&quot;, &quot;不成功便成仁&quot;, &quot;v1.0&quot;, &quot;https://dayanhan.github.io/&quot;, contact, &quot;Apache 2.0&quot;, &quot;http://www.apache.org/licenses/LICENSE-2.0&quot;, new ArrayList() ); &#125;&#125; swagger配置扫描接口Docket.select () .enable(true)//enable是否启动Swagger，如果为false，则Swagger不能在浏览器中访问 123456789101112131415161718192021@Configuration//声明配置类@EnableOpenApi//开启swagger3public class SwaggerConfig &#123; //配置Swagger的Docket的bean实例 @Bean public Docket docket()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .enable(true)//enable是否启动Swagger，如果为false，则Swagger不能在浏览器中访问 .select() //RequestHandlerSelectors,配置要扫描接口的方式 //basePackage，指定要扫描的包 //any()，扫描全部 //none(),不扫描 //withClassAnnotation，扫描类上的注解，参数是一个注解类的反射对象 //withMethodAnnotation，扫描方法上的注解 .apis(RequestHandlerSelectors.basePackage(&quot;com.ayan.swagger.controller&quot;)) //path(),过滤什么路径,ant(&quot;&quot;),过滤指定路径就扫描不到了 //.paths(PathSelectors.ant(&quot;/ayan/**&quot;)) .build(); &#125; 配置API文档分组1.groupName(&quot;阿焱&quot;) 如何配置多个分组；多个Docket 实例即可，但是不要重名！ 123456789101112@Bean public Docket docket1()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;A&quot;); &#125; @Bean public Docket docket2()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;B&quot;); &#125; @Bean public Docket docket3()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;C&quot;); &#125; 实体类配置 123456789101112package com.ayan.swagger.pojo;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;//@Api(注释)@ApiModel(&quot;用户实体类&quot;)public class User &#123; @ApiModelProperty(&quot;用户名&quot;) public String username; @ApiModelProperty(&quot;密码&quot;) public String password;&#125; controller配置 12345678910111213141516171819202122232425262728293031323334package com.ayan.swagger.controller;import com.ayan.swagger.pojo.User;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import io.swagger.annotations.ApiParam;import org.springframework.web.bind.annotation.*;@Api(tags = &quot;Hello控制器类&quot;)@RestController@RequestMapping(value = &quot;/hello&quot;)public class HelloController &#123; @GetMapping(value = &quot;/hello&quot;) public String hello()&#123; return &quot;hello world!&quot;; &#125; //只要我们的接口中，返回值中存在实体类，他就会被扫描到swagger中 @PostMapping(value = &quot;/user&quot;) public User user()&#123; return new User(); &#125; //Operation接口,不是放在类上的，是方法 @ApiOperation(&quot;Hello2方法&quot;) @GetMapping(value = &quot;/hello2&quot;) public String hello2(@ApiParam(&quot;用户名&quot;) String username)&#123; return &quot;hello&quot;+username; &#125; //Operation接口,不是放在类上的，是方法 @ApiOperation(&quot;post提交用户测试方法&quot;) @PostMapping(value = &quot;/postuser&quot;) public User postuser(@ApiParam(&quot;用户信息&quot;) @RequestBody User user)&#123; return user; &#125;&#125; 总结： 我们可以通过Swagger给一些比较难理解的属性或者接口，增加注释信息 接口文档实时更新 可以在线测试 Swagger是一个优秀的工具，几乎所有大公司都有使用它 【注意点】在正式发布的时候，关闭Swagger！！！出于安全考虑。而且节省运行的内存；","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2021-11-06T10:26:47.000Z","updated":"2021-11-15T15:17:56.402Z","comments":true,"path":"2021/11/06/我的第一篇博客文章/","link":"","permalink":"http://example.com/2021/11/06/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"第一章java基础篇章内容1 第二章内容2参考文献内容3","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-11-06T10:18:02.882Z","updated":"2021-11-06T10:18:02.882Z","comments":true,"path":"2021/11/06/hello-world/","link":"","permalink":"http://example.com/2021/11/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]}